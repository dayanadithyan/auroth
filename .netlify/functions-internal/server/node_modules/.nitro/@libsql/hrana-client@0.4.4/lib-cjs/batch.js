"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BatchCond = exports.BatchStep = exports.Batch = void 0;
const errors_js_1 = require("./errors.js");
const result_js_1 = require("./result.js");
const stmt_js_1 = require("./stmt.js");
/** A builder for creating a batch and executing it on the server. */
class Batch {
    /** @private */
    _stream;
    #executed;
    /** @private */
    _steps;
    /** @private */
    _resultCallbacks;
    /** @private */
    constructor(stream) {
        this._stream = stream;
        this.#executed = false;
        this._steps = [];
        this._resultCallbacks = [];
    }
    /** Return a builder for adding a step to the batch. */
    step() {
        return new BatchStep(this);
    }
    /** Execute the batch. */
    execute() {
        if (this.#executed) {
            throw new Error("This batch has already been executed");
        }
        this.#executed = true;
        const batch = {
            "steps": this._steps,
        };
        return this._stream._batch(batch).then((result) => {
            for (const callback of this._resultCallbacks) {
                callback(result);
            }
        });
    }
}
exports.Batch = Batch;
/** A builder for adding a step to the batch. */
class BatchStep {
    #batch;
    #conditions;
    /** @private */
    _index;
    /** @private */
    constructor(batch) {
        this.#batch = batch;
        this.#conditions = [];
        this._index = undefined;
    }
    /** Add the condition that needs to be satisfied to execute the statement. If you use this method multiple
    * times, we join them with a logical AND. */
    condition(cond) {
        this.#conditions.push(cond._proto);
        return this;
    }
    /** Add a statement that returns rows. */
    query(stmt) {
        return this.#add(stmt, true, result_js_1.rowsResultFromProto);
    }
    /** Add a statement that returns at most a single row. */
    queryRow(stmt) {
        return this.#add(stmt, true, result_js_1.rowResultFromProto);
    }
    /** Add a statement returns at most a single value. */
    queryValue(stmt) {
        return this.#add(stmt, true, result_js_1.valueResultFromProto);
    }
    /** Add a statement without returning rows. */
    run(stmt) {
        return this.#add(stmt, false, result_js_1.stmtResultFromProto);
    }
    #add(inStmt, wantRows, fromProto) {
        const stmt = (0, stmt_js_1.stmtToProto)(this.#batch._stream._sqlOwner(), inStmt, wantRows);
        if (this._index !== undefined) {
            throw new Error("This step has already been added to the batch");
        }
        const index = this.#batch._steps.length;
        this._index = index;
        let condition;
        if (this.#conditions.length === 0) {
            condition = null;
        }
        else if (this.#conditions.length === 1) {
            condition = this.#conditions[0];
        }
        else {
            condition = { "type": "and", "conds": this.#conditions };
        }
        this.#batch._steps.push({
            "stmt": stmt,
            "condition": condition,
        });
        return new Promise((outputCallback, errorCallback) => {
            this.#batch._resultCallbacks.push((result) => {
                const stepResult = result["step_results"][index];
                const stepError = result["step_errors"][index];
                if (stepResult === undefined || stepError === undefined) {
                    errorCallback(new errors_js_1.ProtoError("Server returned fewer step results than expected"));
                }
                else if (stepResult !== null && stepError !== null) {
                    errorCallback(new errors_js_1.ProtoError("Server returned both result and error"));
                }
                else if (stepError !== null) {
                    errorCallback((0, result_js_1.errorFromProto)(stepError));
                }
                else if (stepResult !== null) {
                    outputCallback(fromProto(stepResult, this.#batch._stream.intMode));
                }
                else {
                    outputCallback(undefined);
                }
            });
        });
    }
}
exports.BatchStep = BatchStep;
class BatchCond {
    /** @private */
    _proto;
    /** @private */
    constructor(proto) {
        this._proto = proto;
    }
    static ok(step) {
        return new BatchCond({ "type": "ok", "step": stepIndex(step) });
    }
    static error(step) {
        return new BatchCond({ "type": "error", "step": stepIndex(step) });
    }
    static not(cond) {
        return new BatchCond({ "type": "not", "cond": cond._proto });
    }
    static and(conds) {
        return new BatchCond({ "type": "and", "conds": conds.map(e => e._proto) });
    }
    static or(conds) {
        return new BatchCond({ "type": "or", "conds": conds.map(e => e._proto) });
    }
}
exports.BatchCond = BatchCond;
function stepIndex(step) {
    if (step._index === undefined) {
        throw new Error("Cannot add a condition referencing a step that has not been added to the batch");
    }
    return step._index;
}
