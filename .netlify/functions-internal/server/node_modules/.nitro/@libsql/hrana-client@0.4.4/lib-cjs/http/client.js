"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClient = void 0;
const isomorphic_fetch_1 = require("@libsql/isomorphic-fetch");
const client_js_1 = require("../client.js");
const errors_js_1 = require("../errors.js");
const stream_js_1 = require("./stream.js");
/** A client for the Hrana protocol over HTTP. */
class HttpClient extends client_js_1.Client {
    #url;
    #jwt;
    #fetch;
    #closed;
    #streams;
    /** @private */
    constructor(url, jwt, customFetch) {
        super();
        this.#url = url;
        this.#jwt = jwt;
        this.#fetch = customFetch ?? isomorphic_fetch_1.fetch;
        this.#closed = false;
        this.#streams = new Set();
    }
    /** Get the protocol version supported by the server. */
    getVersion() {
        return Promise.resolve(2);
    }
    /** Open a {@link HttpStream}, a stream for executing SQL statements. */
    openStream() {
        if (this.#closed) {
            throw new errors_js_1.ClosedError("Client is closed", undefined);
        }
        const stream = new stream_js_1.HttpStream(this, this.#url, this.#jwt, this.#fetch);
        this.#streams.add(stream);
        return stream;
    }
    /** @private */
    _streamClosed(stream) {
        this.#streams.delete(stream);
    }
    /** Close the client and all its streams. */
    close() {
        this.#closed = true;
        for (const stream of Array.from(this.#streams)) {
            stream._closeFromClient();
        }
    }
    /** True if the client is closed. */
    get closed() {
        return this.#closed;
    }
}
exports.HttpClient = HttpClient;
