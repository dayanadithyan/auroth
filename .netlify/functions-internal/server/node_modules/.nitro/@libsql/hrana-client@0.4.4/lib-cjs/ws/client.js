"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WsClient = void 0;
const client_js_1 = require("../client.js");
const errors_js_1 = require("../errors.js");
const id_alloc_js_1 = require("../id_alloc.js");
const result_js_1 = require("../result.js");
const sql_js_1 = require("../sql.js");
const stream_js_1 = require("./stream.js");
/** A client for the Hrana protocol over a WebSocket. */
class WsClient extends client_js_1.Client {
    #socket;
    // List of callbacks that we queue until the socket transitions from the CONNECTING to the OPEN state.
    #openCallbacks;
    // Have we already transitioned from CONNECTING to OPEN and fired the callbacks in #openCallbacks?
    #opened;
    // Stores the error that caused us to close the client (and the socket). If we are not closed, this is
    // `undefined`.
    #closed;
    // Have we received a response to our "hello" from the server?
    #recvdHello;
    // Protocol version negotiated with the server. It is only available after the socket transitions to the
    // OPEN state.
    #version;
    // Has the `getVersion()` function been called? This is only used to validate that the API is used
    // correctly.
    #getVersionCalled;
    // A map from request id to the responses that we expect to receive from the server.
    #responseMap;
    // An allocator of request ids.
    #requestIdAlloc;
    // An allocator of stream ids.
    #streamIdAlloc;
    // An allocator of SQL text ids.
    #sqlIdAlloc;
    /** @private */
    constructor(socket, jwt) {
        super();
        this.#socket = socket;
        this.#socket.binaryType = "arraybuffer";
        this.#openCallbacks = [];
        this.#opened = false;
        this.#closed = undefined;
        this.#recvdHello = false;
        this.#version = undefined;
        this.#getVersionCalled = false;
        this.#responseMap = new Map();
        this.#requestIdAlloc = new id_alloc_js_1.IdAlloc();
        this.#streamIdAlloc = new id_alloc_js_1.IdAlloc();
        this.#sqlIdAlloc = new id_alloc_js_1.IdAlloc();
        this.#socket.addEventListener("open", () => this.#onSocketOpen());
        this.#socket.addEventListener("close", (event) => this.#onSocketClose(event));
        this.#socket.addEventListener("error", (event) => this.#onSocketError(event));
        this.#socket.addEventListener("message", (event) => this.#onSocketMessage(event));
        this.#send({ "type": "hello", "jwt": jwt });
    }
    // Send (or enqueue to send) a message to the server.
    #send(msg) {
        if (this.#closed !== undefined) {
            throw new errors_js_1.ClientError("Internal error: trying to send a message on a closed client");
        }
        if (this.#opened) {
            this.#sendToSocket(msg);
        }
        else {
            const openCallback = () => this.#sendToSocket(msg);
            const errorCallback = (_) => undefined;
            this.#openCallbacks.push({ openCallback, errorCallback });
        }
    }
    // The socket transitioned from CONNECTING to OPEN
    #onSocketOpen() {
        const protocol = this.#socket.protocol;
        if (protocol === "") {
            this.#version = 1;
        }
        else if (protocol === undefined) {
            // TODO: This is a workaround for Miniflare, which does not support the `protocol` property on a
            // WebSocket
            this.#version = 1;
        }
        else {
            this.#version = client_js_1.protocolVersions.get(protocol);
            if (this.#version === undefined) {
                this.#setClosed(new errors_js_1.ProtoError(`Unrecognized WebSocket subprotocol: ${JSON.stringify(protocol)}`));
            }
        }
        for (const callbacks of this.#openCallbacks) {
            callbacks.openCallback();
        }
        this.#openCallbacks.length = 0;
        this.#opened = true;
    }
    #sendToSocket(msg) {
        this.#socket.send(JSON.stringify(msg));
    }
    /** Get the protocol version negotiated with the server, possibly waiting until the socket is open. */
    getVersion() {
        return new Promise((versionCallback, errorCallback) => {
            this.#getVersionCalled = true;
            if (this.#closed !== undefined) {
                errorCallback(this.#closed);
            }
            else if (!this.#opened) {
                const openCallback = () => versionCallback(this.#version);
                this.#openCallbacks.push({ openCallback, errorCallback });
            }
            else {
                versionCallback(this.#version);
            }
        });
    }
    // Make sure that the negotiated version is at least `minVersion`.
    /** @private */
    _ensureVersion(minVersion, feature) {
        if (this.#version === undefined || !this.#getVersionCalled) {
            throw new errors_js_1.ProtocolVersionError(`${feature} is supported only on protocol version ${minVersion} and higher, ` +
                "but the version supported by the server is not yet known. Use WsClient.getVersion() " +
                "to wait until the version is available.");
        }
        else if (this.#version < minVersion) {
            throw new errors_js_1.ProtocolVersionError(`${feature} is supported on protocol version ${minVersion} and higher, ` +
                `but the server only supports version ${this.#version}`);
        }
    }
    // Send a request to the server and invoke a callback when we get the response.
    /** @private */
    _sendRequest(request, callbacks) {
        if (this.#closed !== undefined) {
            callbacks.errorCallback(new errors_js_1.ClosedError("Client is closed", this.#closed));
            return;
        }
        const requestId = this.#requestIdAlloc.alloc();
        this.#responseMap.set(requestId, { ...callbacks, type: request.type });
        this.#send({ "type": "request", "request_id": requestId, request });
    }
    // The socket encountered an error.
    #onSocketError(event) {
        const eventMessage = event.message;
        const message = eventMessage ?? "Connection was closed due to an error";
        this.#setClosed(new errors_js_1.WebSocketError(message));
    }
    // The socket was closed.
    #onSocketClose(event) {
        let message = `WebSocket was closed with code ${event.code}`;
        if (event.reason) {
            message += `: ${event.reason}`;
        }
        this.#setClosed(new errors_js_1.WebSocketError(message));
    }
    // Close the client with the given error.
    #setClosed(error) {
        if (this.#closed !== undefined) {
            return;
        }
        this.#closed = error;
        for (const callbacks of this.#openCallbacks) {
            callbacks.errorCallback(error);
        }
        this.#openCallbacks.length = 0;
        for (const [requestId, responseState] of this.#responseMap.entries()) {
            responseState.errorCallback(error);
            this.#requestIdAlloc.free(requestId);
        }
        this.#responseMap.clear();
        this.#socket.close();
    }
    // We received a message from the socket.
    #onSocketMessage(event) {
        if (this.#closed !== undefined) {
            return;
        }
        if (typeof event.data !== "string") {
            this.#socket.close(3003, "Only string messages are accepted");
            this.#setClosed(new errors_js_1.ProtoError("Received non-string message from server"));
            return;
        }
        try {
            this.#handleMsg(event.data);
        }
        catch (e) {
            this.#socket.close(3007, "Could not handle message");
            this.#setClosed(e);
        }
    }
    // Handle a message from the server.
    #handleMsg(msgText) {
        const msg = JSON.parse(msgText);
        if (msg["type"] === "hello_ok" || msg["type"] === "hello_error") {
            if (this.#recvdHello) {
                throw new errors_js_1.ProtoError("Received a duplicated hello response");
            }
            this.#recvdHello = true;
            if (msg["type"] === "hello_error") {
                throw (0, result_js_1.errorFromProto)(msg["error"]);
            }
            return;
        }
        else if (!this.#recvdHello) {
            throw new errors_js_1.ProtoError("Received a non-hello message before a hello response");
        }
        if (msg["type"] === "response_ok") {
            const requestId = msg["request_id"];
            const responseState = this.#responseMap.get(requestId);
            this.#responseMap.delete(requestId);
            if (responseState === undefined) {
                throw new errors_js_1.ProtoError("Received unexpected OK response");
            }
            this.#requestIdAlloc.free(requestId);
            try {
                if (responseState.type !== msg["response"]["type"]) {
                    throw new errors_js_1.ProtoError("Received unexpected type of response");
                }
                responseState.responseCallback(msg["response"]);
            }
            catch (e) {
                responseState.errorCallback(e);
                throw e;
            }
        }
        else if (msg["type"] === "response_error") {
            const requestId = msg["request_id"];
            const responseState = this.#responseMap.get(requestId);
            this.#responseMap.delete(requestId);
            if (responseState === undefined) {
                throw new errors_js_1.ProtoError("Received unexpected error response");
            }
            this.#requestIdAlloc.free(requestId);
            responseState.errorCallback((0, result_js_1.errorFromProto)(msg["error"]));
        }
        else {
            throw new errors_js_1.ProtoError("Received unexpected message type");
        }
    }
    /** Open a {@link WsStream}, a stream for executing SQL statements. */
    openStream() {
        const streamId = this.#streamIdAlloc.alloc();
        const streamState = {
            streamId,
            closed: undefined,
        };
        const responseCallback = () => undefined;
        const errorCallback = (e) => this._closeStream(streamState, e);
        const request = {
            "type": "open_stream",
            "stream_id": streamId,
        };
        this._sendRequest(request, { responseCallback, errorCallback });
        return new stream_js_1.WsStream(this, streamState);
    }
    // Make sure that the stream is closed.
    /** @private */
    _closeStream(streamState, error) {
        if (streamState.closed !== undefined || this.#closed !== undefined) {
            return;
        }
        streamState.closed = error;
        const callback = () => {
            this.#streamIdAlloc.free(streamState.streamId);
        };
        const request = {
            "type": "close_stream",
            "stream_id": streamState.streamId,
        };
        this._sendRequest(request, { responseCallback: callback, errorCallback: callback });
    }
    // Send a stream-specific request to the server and invoke a callback when we get the response.
    /** @private */
    _sendStreamRequest(streamState, request, callbacks) {
        if (streamState.closed !== undefined) {
            callbacks.errorCallback(new errors_js_1.ClosedError("Stream is closed", streamState.closed));
            return;
        }
        this._sendRequest(request, callbacks);
    }
    /** Cache a SQL text on the server. This requires protocol version 2 or higher. */
    storeSql(sql) {
        this._ensureVersion(2, "storeSql()");
        const sqlId = this.#sqlIdAlloc.alloc();
        const sqlState = {
            sqlId,
            closed: undefined,
        };
        const responseCallback = () => undefined;
        const errorCallback = (e) => this._closeSql(sqlState, e);
        const request = {
            "type": "store_sql",
            "sql_id": sqlId,
            "sql": sql,
        };
        this._sendRequest(request, { responseCallback, errorCallback });
        return new sql_js_1.Sql(this, sqlState);
    }
    // Make sure that the SQL text is closed.
    /** @private */
    _closeSql(sqlState, error) {
        if (sqlState.closed !== undefined || this.#closed !== undefined) {
            return;
        }
        sqlState.closed = error;
        const callback = () => {
            this.#sqlIdAlloc.free(sqlState.sqlId);
        };
        const request = {
            "type": "close_sql",
            "sql_id": sqlState.sqlId,
        };
        this._sendRequest(request, { responseCallback: callback, errorCallback: callback });
    }
    /** Close the client and the WebSocket. */
    close() {
        this.#setClosed(new errors_js_1.ClientError("Client was manually closed"));
    }
    /** True if the client is closed. */
    get closed() {
        return this.#closed !== undefined;
    }
}
exports.WsClient = WsClient;
