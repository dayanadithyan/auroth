import{AsyncLocalStorage as R}from"node:async_hooks";import{H3Event as h,getRequestWebStream as _,getRequestURL as b,eventHandler as x}from"h3";function S(t={}){let e,o=!1;const r=n=>{if(e&&e!==n)throw new Error("Context conflict")};let s;if(t.asyncContext){const n=t.AsyncLocalStorage||globalThis.AsyncLocalStorage;n?s=new n:console.warn("[unctx] `AsyncLocalStorage` is not provided.")}const a=()=>{if(s){const n=s.getStore();if(n!==void 0)return n}return e};return{use:()=>{const n=a();if(n===void 0)throw new Error("Context is not available");return n},tryUse:()=>a(),set:(n,i)=>{i||r(n),e=n,o=!0},unset:()=>{e=void 0,o=!1},call:(n,i)=>{r(n),e=n;try{return s?s.run(n,i):i()}finally{o||(e=void 0)}},async callAsync(n,i){e=n;const u=()=>{e=n},l=()=>e===n?u:void 0;g.add(l);try{const f=s?s.run(n,i):i();return o||(e=void 0),await f}finally{g.delete(l)}}}}function T(t={}){const e={};return{get(o,r={}){return e[o]||(e[o]=S({...t,...r})),e[o]}}}const d=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof global<"u"?global:typeof window<"u"?window:{},p="__unctx__",A=d[p]||(d[p]=T()),E=(t,e={})=>A.get(t,e),y="__unctx_async_handlers__",g=d[y]||(d[y]=new Set);function H(t){let e;const o=v(t),r={duplex:"half",method:t.method,headers:t.headers};return t.node.req.body instanceof ArrayBuffer?new Request(o,{...r,body:t.node.req.body}):new Request(o,{...r,get body(){return e||(e=$(t),e)}})}function I(t){return t.web??(t.web={request:H(t),url:v(t)}),t.web.request}function C(){return U()}const P=Symbol("$HTTPEvent");function L(t){return typeof t=="object"&&(t instanceof h||t?.[P]instanceof h||t?.__is_event__===!0)}function w(t){return function(...e){var o;const r=e[0];if(L(r))e[0]=r instanceof h||r.__is_event__?r:r[P];else{if(!((o=globalThis.app.config.server.experimental)!=null&&o.asyncContext))throw new Error("AsyncLocalStorage was not enabled. Use the `server.experimental.asyncContext: true` option in your app configuration to enable it. Or, pass the instance of HTTPEvent that you have as the first argument to the function.");e.unshift(C())}return t(...e)}}const v=w(b),$=w(_);function q(){var t;return E("nitro-app",{asyncContext:!!((t=globalThis.app.config.server.experimental)!=null&&t.asyncContext),AsyncLocalStorage:R})}function U(){const t=q().use().event;if(!t)throw new Error("No HTTPEvent found in AsyncLocalStorage. Make sure you are using the function within the server runtime.");return t}const W=[{path:"/__root",filePath:"/Users/devinda/Projects/auroth/app/routes/__root.tsx"},{path:"/chats/:$chatId?",filePath:"/Users/devinda/Projects/auroth/app/routes/chats.$chatId.tsx"},{path:"/",filePath:"/Users/devinda/Projects/auroth/app/routes/index.tsx"},{path:"/api/chat",filePath:"/Users/devinda/Projects/auroth/app/routes/api/chat.ts",$APIRoute:{src:"app/routes/api/chat.ts?pick=APIRoute",build:()=>import("../chat.js"),import:()=>import("../chat.js")}}],B=["GET","POST","PUT","PATCH","DELETE","OPTIONS","HEAD"];function D(t){return x(async e=>{const o=I(e);return await t({request:o})})}const j=t=>e=>({path:t,methods:e});function N(t,e){const o=t.pathname.split("/").filter(Boolean),r=e.sort((s,a)=>{const n=s.routePath.split("/").filter(Boolean);return a.routePath.split("/").filter(Boolean).length-n.length}).filter(s=>{const a=s.routePath.split("/").filter(Boolean);return o.length>=a.length});for(const s of r){const a=s.routePath.split("/").filter(Boolean),n={};let i=!0;for(let u=0;u<a.length;u++){const l=a[u],f=o[u];if(l.startsWith("$"))if(l==="$"){const c=o.slice(u).join("/");if(c!=="")n["*"]=c,n._splat=c;else{i=!1;break}}else{const c=l.slice(1);n[c]=f}else if(l!==f){i=!1;break}}if(i)return{routePath:s.routePath,params:n,payload:s.payload}}}const m=W.filter(t=>t.$APIRoute);function F(t){const e=[];return t.forEach(o=>{const s=o.path.split("/").filter(Boolean).map(a=>a==="*splat"?"$":a.startsWith(":$")&&a.endsWith("?")?a.slice(1,-1):a).join("/");e.push({routePath:`/${s}`,payload:o})}),e}const K=async({request:t})=>{if(!m.length)return new Response("No routes found",{status:404});if(!B.includes(t.method))return new Response("Method not allowed",{status:405});const e=F(m),o=new URL(t.url,"http://localhost:3000"),r=N(o,e);if(!r)return new Response("Not found",{status:404});let s;try{s=await r.payload.$APIRoute.import().then(i=>i.APIRoute)}catch(i){return console.error("Error importing route file:",i),new Response("Internal server error",{status:500})}if(!s)return new Response("Internal server error",{status:500});const a=t.method,n=s.methods[a];return n?await n({request:t,params:r.params}):new Response("Method not allowed",{status:405})};export{j as a,D as c,K as d};
