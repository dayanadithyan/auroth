import{createDataStream as w,generateId as S,LangChainAdapter as U,appendResponseMessages as L}from"ai";import{createResumableStreamContext as b}from"resumable-stream";import{waitUntil as _}from"@vercel/functions";import{drizzle as O}from"drizzle-orm/libsql";import{createEnv as P}from"@t3-oss/env-core";import{z as r}from"zod";import{sql as R,eq as I}from"drizzle-orm";import{sqliteTable as E,integer as T,text as d}from"drizzle-orm/sqlite-core";import{OpenAIEmbeddings as M,ChatOpenAI as j}from"@langchain/openai";import{SqlToolkit as $}from"langchain/agents/toolkits/sql";import{SqlDatabase as D}from"langchain/sql_db";import{DataSource as A}from"typeorm";import{pull as k}from"langchain/hub";import{createReactAgent as K}from"@langchain/langgraph/prebuilt";import{Document as Y}from"@langchain/core/documents";import{MemoryVectorStore as z}from"langchain/vectorstores/memory";import{tool as J}from"@langchain/core/tools";import{HumanMessage as V,AIMessage as B}from"@langchain/core/messages";import{a as F}from"./assets/index-BJ0g3EOC.js";import"node:async_hooks";import"h3";const N=P({server:{OPENAI_API_KEY:r.string().min(1),TURSO_KEY:r.string().min(1),TURSO_URL:r.string().min(1),REDIS_URL:r.string().min(1),POSTGRES_DATABASE_URL:r.string().min(1)},clientPrefix:"PUBLIC_",client:{},runtimeEnv:process.env,emptyStringAsUndefined:!0}),g=O({connection:{url:N.TURSO_URL,authToken:N.TURSO_KEY}}),f=E("chats",{id:d("id").primaryKey(),messages:d("messages",{mode:"json"}).notNull().$type(),createdAt:T("created_at",{mode:"number"}).notNull().default(R`(unixepoch())`),updatedAt:T("updated_at",{mode:"number"}).notNull().default(R`(unixepoch())`)}),y=E("streams",{id:d("id").primaryKey(),chat_id:d("chat_id").notNull()});async function G(e,t){await g.insert(f).values({id:e,messages:t}).onConflictDoUpdate({target:f.id,set:{messages:t}})}async function W(e){const t=await g.select().from(f).where(I(f.id,e));return t.length<1?[]:t}async function H({chatId:e,streamId:t}){await g.insert(y).values({id:t,chat_id:e})}async function Q(e){return await g.select().from(y).where(I(y.chat_id,e))}const X=new A({type:"sqlite",database:"dota.db"}),u=await D.fromDataSourceParams({appDataSource:X});async function l(e,t){return JSON.parse(await e.run(t)).flat().filter(a=>a!=null).map(a=>Object.values(a)[0].replace(/\b\d+\b/g,"").trim()).filter(a=>a!=="")}function p(e){return new Y(e)}async function Z(){const e=(await l(u,"SELECT display_name from heroes")).map(s=>p({pageContent:s,metadata:{columnName:"display_name",table:"heroes"}})),t=(await l(u,"SELECT display_name from items")).map(s=>p({pageContent:s,metadata:{columnName:"display_name",table:"items"}})),n=(await l(u,"SELECT name from team_players")).map(s=>p({pageContent:s,metadata:{columnName:"name",table:"team_players"}})),o=(await l(u,"SELECT name from teams")).map(s=>p({pageContent:s,metadata:{columnName:"name",table:"team"}}));return e.concat(t,n,o)}const ee=new M({model:"text-embedding-3-large"}),q=new z(ee),te=await Z();await q.addDocuments(te);const ae=q.asRetriever(5),se=J(async e=>{const t=await ae.invoke(e.query);return console.log(t),t.map((n,o)=>`Result ${o+1}:
Content: ${n.pageContent}
Metadata: ${JSON.stringify(n.metadata)}`).join(`

`)},{name:"searchProperNouns",description:"Use to look up values to filter on. Input is an approximate spelling of the proper noun, output is valid proper nouns. Use the noun most similar to the search.",schema:r.object({query:r.string().describe("The proper noun to search for")})}),oe=new A({type:"sqlite",database:"dota.db"}),ne=await D.fromDataSourceParams({appDataSource:oe}),v=new j({model:"o4-mini",temperature:1}),re=new $(ne,v),ie=re.getTools().concat(se),me=await k("langchain-ai/sql-agent-system-prompt");let ce=`
If you need to filter on a proper noun like a Name, you must ALWAYS first look up the filter value using the 'search_proper_nouns' tool! Do not try to guess at the proper name - use this function to find similar ones. The pageContent attribute is the proper name, and the metadata attribute includes which table and column that proper name is from.`;const ue=await me.format({dialect:"SQLite",top_k:5}),le=ue+ce,pe=K({llm:v,tools:ie,stateModifier:le});async function de(e,t){const n=await pe.stream({messages:t},{configurable:{thread_id:e}}),o=new TransformStream({transform(a,s){console.log(a),a.agent&&a.agent.messages.at(-1).response_metadata.finish_reason==="stop"&&s.enqueue(a.agent.messages.at(-1).content)}});return n.pipeThrough(o)}function fe(e){return e.map(n=>{const{id:o,content:a,...s}=n;return n.role==="user"?new V({id:o,content:a,response_metadata:{...s}}):new B({id:o,content:a,response_metadata:{...s}})})}const Pe=F("/api/chat")({POST:async({request:e})=>{const t=b({waitUntil:_}),{messages:n,id:o}=await e.json(),a=S();await H({chatId:o,streamId:a}),console.log("appended stream id",a);const s=fe(n),h=await de(o,s),m=w({execute:async c=>{console.log("success"),U.mergeIntoDataStream(h,{dataStream:c,callbacks:{async onFinal(i){await G(o,L({messages:n,responseMessages:[{content:i,role:"assistant",id:S()}]}))}}})}});return console.log("returned post request"),new Response(await t.createNewResumableStream(a,()=>m))},GET:async({request:e})=>{const{searchParams:t}=new URL(e.url),n=b({waitUntil:_}),o=t.get("chatId");if(!o)return console.log("id is required"),new Response("id is required",{status:400});const a=await Q(o);if(!a.length)return console.log("No Streams found"),new Response("No Streams found",{status:404});const s=a.at(-1)?.id;if(!s)return console.log("No recent stream found"),new Response("No recent stream found",{status:404});console.log("lastStreamId",s);const h=w({execute:()=>{}}),m=await n.resumeExistingStream(s);if(m)return console.log("found stream"),new Response(m,{status:200});console.log("stream is already done");const[c]=await W(o);console.log("result",c);const i=c.messages.at(-1);if(!i||i.role!=="assistant")return new Response(h,{status:200});const C=w({execute:x=>{x.writeData({type:"append-message",message:JSON.stringify(i)})}});return new Response(C,{status:200})}});export{Pe as APIRoute};
